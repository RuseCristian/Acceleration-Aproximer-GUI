import numpy as np
import plotly.graph_objects as go
from kivy.core.window import Window
from kivy.lang.builder import Builder
from kivy.metrics import sp
from kivy.properties import StringProperty
from kivy.uix.screenmanager import Screen
from kivy.uix.widget import Widget
from kivymd.app import MDApp
from kivymd.uix.boxlayout import MDBoxLayout
from kivymd.uix.button import MDFlatButton
from kivymd.uix.dialog import MDDialog
from kivymd.uix.floatlayout import MDFloatLayout
from kivymd.uix.list import OneLineIconListItem
from kivymd.uix.menu import MDDropdownMenu
from kivymd.uix.tab import MDTabsBase
from kivymd.uix.textfield import MDTextField
from plotly.subplots import make_subplots
from scipy.interpolate import interp1d

Builder.load_file("aero_screen.kv")
Builder.load_file("car_info_screen.kv")
Builder.load_file("drivetrain_screen.kv")
Builder.load_file("engine_screen.kv")
# Builder.load_file("info_screen.kv")
Builder.load_file("results_screen.kv")
Builder.load_file("settings_screen.kv")
Builder.load_file("tire_screen.kv")


class Tab(MDFloatLayout, MDTabsBase):
    '''Class implementing content for a tab.'''


class ContentNavigationDrawer(MDBoxLayout):
    pass


class SettingsScreen(Screen):
    pass
    # switchTestMode = ObjectProperty(active=True)
    # testModus = BooleanProperty(store.get('mode')['dev'])
    #
    # def save_settings(self):
    #     print(self.switchTestMode.active)
    #     store.put('mode', dev=self.switchTestMode.active)
    #     print("saved settings")
    #


class InfoScreen(Screen):
    pass


class MainScreen(Screen):
    pass


class CarScreen(Screen):
    pass


class EngineScreen(Screen):
    pass


class DrivetrainScreen(Screen):
    pass


class TireScreen(Screen):
    pass


class AeroScreen(Screen):
    pass


class ResultsScreen(Screen):
    pass


dialog_text_dictionary = {
    "add_gear": "Select the number of gears your car has and input their gear ratios.",
    "downforce": "Downforce is a downward force that is generated by the aerodynamic design of a car. This force pushes the car onto the ground, increasing the "
                 "friction between the tires and the road surface, which increases the car's grip. Without downforce, "
                 "the car's grip limit would be significantly lower, and it would be more challenging to accelerate.",
    "weight_shifting": "When a car accelerates, its body wants to stay put due to its inertia. This causes the weight of the car to shift towards the rear, "
                       "which helps increase the grip on the rear wheels. This simulates said phenomena, but needs some hard to get information, thus it is optional.",
    "car_mass_distribution": "Car mass distribution refers to how the weight of a car is distributed among its 2 axles, front and rear, due to its components, "
                             "such as the engine, chassis, and wheels. A car with more mass on the driven wheels will allow for better acceleration in lower gears. ",
    "car_wheel_base": "The wheelbase of a car represents the distance between the front and rear axles, measured from the geometric center of the wheels. A longer "
                      "wheelbase generally means that the effect of squatting when accelerating is lower.",
    "car_roll_center_height": "Roll center height is a suspension geometry parameter that determines the height of the imaginary point around which a car's body rolls "
                              "or pivots when it is subject to lateral forces. When a car is accelerating in a straight line, the roll center height has no direct "
                              "impact on its behavior. However, it can indirectly affect acceleration performance by influencing weight transfer during launch. A "
                              "higher roll center height can cause more weight transfer to the rear wheels during acceleration, which can improve traction and grip, "
                              "while a lower roll center height can reduce weight transfer and potentially reduce traction and grip.",
    "car_track_width": "Track car width refers to the distance between the left and right wheels of a car on the driven axle.",
    "car_roll_stiffness": "Roll stiffness refers to the car's resistance to body roll or lean during cornering. It is determined by the car's suspension geometry, "
                          "including the spring rates, anti-roll bars, and roll center height. A car with high roll stiffness will resist body roll more, "
                          "improving stability and handling during cornering, while a car with low roll stiffness will experience more body roll, potentially reducing "
                          "grip and stability.",
    "engine_idle_rpm": "Idle RPM (Revolutions Per Minute) is the speed at which a car's engine crankshaft rotates when the engine is in idle or neutral gear and there "
                       "is no load on the engine. In other words, it is the minimum speed at which the engine can operate without stalling.",
    "engine_redline_rpm": "The redline RPM is the maximum engine speed at which an engine can operate without causing damage to its internal components. ",
    "add_rpm_torque_entries": "Add RPM:Torque values for the engine horsepower and torque graphs. In the left field input the RPM and in the right filed input the torque at said "
                              "RPM. RPM entries must be made in an increasing manner. I.e if RPM entry 1 is 3000, RPM entry 2 cannot be 2500.",
    "drivetrain_layout": "A car's layout refers to how its drivetrain is configured to deliver power to the wheels. Rear-wheel drive (RWD) provides better handling but "
                         "can be less practical, front-wheel drive (FWD) provides better traction in slippery conditions, while all-wheel drive (AWD) delivers power to "
                         "all four wheels offers best all around traction, but usually comes with a bigger mass handicap.",
    "drivetrain_loss": "Drivetrain loss is the amount of power lost between the engine and the wheels due to friction and other inefficiencies in the drivetrain. It is "
                       "expressed as a percentage of the engine's total output and can vary between 5% and 15%, depending on the car's make and model and the type of "
                       "transmission and other components used.",
    "drivetrain_shift_time": "Shifting time represents how much time elapses from the moment the the car disengages the driven wheels from the engine, switches to the "
                             "next gear and then fully engages the driven wheels. A skilled driver can do this in about 0.25s in a manual car, while automatic cars can "
                             "do it a lot faster depending on the type of transmission and technologies used, example: Porsche's PDK can up-shift in just a few "
                             "milliseconds.",
    "drivetrain_off_clutch": "Off Clutch Rpm represents the rpm value at which the clutch is fully disengaged ( in starting from a stop conditions )."
                             "\n\nRestraints : Idle RPM < Off Clutch RPM < Redline RPM",
    "drivetrain_gas_level": "Gas Level represents how much the driver is pressing the gas pedal in terms of percentages, where 0 - represents not pressed at all, "
                            "and 1 represents fully pressed. ( in starting from a stop conditions ) If the user inputs a very low gas level ( lower than the minimum "
                            "needed to start moving the car), the program will use the minimum value needed to move the car instead.",
    "drivetrain_final_gear": "The final gear ratio refers to the ratio between the rotational speed of the car's drive shaft and the rotational speed of the wheels. It "
                             "is determined by the ratio between the number of teeth on the ring gear and the pinion gear in the differential. A higher ratio will "
                             "provide more acceleration (provided there is sufficient grip) but lower top speed, while a lower ratio will provide less acceleration but "
                             "higher top speed.",
    "tire_width": "The tire width is the width of the tire's contact patch with the road surface, which can be determined by reading the first three values on the "
                  "tire's sidewall, where the first number represents the tire width in millimeters.",
    "tire_aspect_ratio": "The tire aspect ratio is the height of a tire's sidewall expressed as a percentage of the tire's width, which can be determined by reading "
                         "the second value on the tire's sidewall. The aspect ratio affects the tire's overall diameter, with lower ratios providing a smaller diameter "
                         "and a shorter effective final gear ratio, resulting in faster acceleration, lower top speeds, and higher ratios result in lower acceleration "
                         "but higher top speeds.",
    "tire_wheel_diameter": "Wheel diameter refers to the distance across a wheel at its widest point. A larger wheel diameter can improve top speed but decrease "
                           "acceleration, while a smaller diameter can do the opposite. The tire's sidewall displays three values: width, aspect ratio, and diameter, "
                           "with the diameter being the third number, measured in inches.",
    "tire_friction_coeff": "Tire friction coefficient is the measure of grip between the tire and the road surface. It affects acceleration because a higher "
                           "coefficient of friction means the tire can transfer more force to the road, resulting in faster acceleration. Conversely, "
                           "a lower coefficient of friction means less grip and slower acceleration.",
    "tire_rolling_res_coeff": "Rolling resistance is the force required to keep a tire rolling. It is caused by the deformation of the tire as it rolls and the "
                              "friction between the tire and the road. Rolling resistance affects acceleration because it can act as a drag force, slowing down the "
                              "vehicle and reducing acceleration. Tires with lower rolling resistance require less force to roll and can improve acceleration and fuel "
                              "efficiency.",
    "aero_drag_coeff": "Coefficient of drag is a measure of resistance experienced by an object as it moves through a fluid. Higher values mean more resistance, "
                       "lower efficiency, and reduced acceleration, conversely lower values mean better acceleration.",
    "aero_frontal_area": "Frontal area of a car is the total area of its front surface that faces the direction of motion. It includes the area of the hood, "
                         "windshield, and front side windows. It affects the amount of air resistance the car encounters while moving, with larger frontal areas "
                         "generally leading to higher drag and slower acceleration.",
    "aero_air_density": "Air density is a measure of the mass of air per unit volume. It depends on factors such as temperature, pressure, and humidity. As air density "
                        "increases, the air becomes more resistant to motion, which can reduce acceleration. This is because a denser fluid provides more resistance, "
                        "resulting in greater drag forces acting on an object moving through it.",
    "results_initial_speed": "Initial Speed represents the speed at which the estimation first starts.\n\nRestraints: 0 <= Initial Speed < Final Speed",
    "results_final_speed": "Final Speed represents the speed at which the estimation ends. \n\nRestraints: Initial Speed < Final Speed <= Max Reachable Speed",
}


class IconListItem(OneLineIconListItem):
    icon = StringProperty()


class AccelerationApproximator(MDApp):

    def build(self):
        self.theme_cls.primary_palette = "BlueGray"
        self.theme_cls.theme_style = "Dark"
        self.screen = Builder.load_file('main_ui.kv')
        self.dialog = None
        self.rpm_torque_rows = 0

        menu_items = [
            {
                "viewclass": "OneLineListItem",
                "text": "2",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="2": self.callback(item, text)
            },
            {
                "viewclass": "OneLineListItem",
                "text": "3",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="3": self.callback(item, text)
            },
            {
                "viewclass": "OneLineListItem",
                "text": "4",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="4": self.callback(item, text)
            },
            {
                "viewclass": "OneLineListItem",
                "text": "5",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="5": self.callback(item, text)
            },
            {
                "viewclass": "OneLineListItem",
                "text": "6",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="6": self.callback(item, text)
            },
            {
                "viewclass": "OneLineListItem",
                "text": "7",
                "on_release": lambda item=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button, text="7": self.callback(item, text)
            }
        ]

        self.dropdown1 = MDDropdownMenu(items=menu_items, width_mult=4, caller=self.screen.ids.main_screen.ids.drivetrainscreen_1.ids.button)
        Window.size = (1080, 2220)
        return self.screen

    def callback(self, item, text):
        self.number_of_gears = int(text)
        self.remove_gear_text_fields()
        self.add_gear_text_fields()

    def show_hide_ui(self, switchObject, switchValue, *args):
        if switchValue:
            for i in args:
                i.visible = True
        else:
            for i in args:
                i.visible = False

    def dialog_information(self, dictionary_entry):

        if not self.dialog:
            self.dialog = MDDialog(
                text=dialog_text_dictionary[dictionary_entry],
                buttons=[
                    MDFlatButton(
                        text="Continue",
                        theme_text_color="Primary",
                        text_color=self.theme_cls.primary_color,
                        on_press=lambda x: (self.close_dialog(), self.dialog.dismiss(), setattr(self, 'dialog', None))
                    )
                ],
            )
        self.dialog.open()

    def close_dialog(self):
        self.dialog.dismiss()

    def add_rpm_torque_text_field(self):

        self.rpm_torque_rows += 1
        self.box_layout = MDBoxLayout(orientation='horizontal', size_hint_x=.5, spacing=sp(20), id=f"rpm_torque{self.rpm_torque_rows}_boxlayout",
                                      pos_hint={"center_x": 0.5, "center_y": 0.5}, adaptive_width=False)
        self.widget = Widget(size_hint_x=0.1)
        self.rpm_text_field = MDTextField(hint_text=f"RPM",
                                          on_text_validate=lambda widget: self.next_text_field(widget, True),
                                          mode="fill", width=sp(150),
                                          size_hint_x=None,
                                          input_filter="float")

        self.torque_text_field = MDTextField(hint_text=f"Torque",
                                             on_text_validate=lambda widget: self.next_text_field(widget, True),
                                             mode="fill", width=sp(150),
                                             size_hint_x=None,
                                             input_filter="float")

        self.box_layout.add_widget(self.widget)
        self.box_layout.add_widget(self.rpm_text_field)
        self.box_layout.add_widget(self.torque_text_field)
        engine_screen = self.root.ids.main_screen.ids.enginescreen_1.ids.engine_vertical_box_layout
        engine_screen.add_widget(self.box_layout)

    def remove_rpm_torque_text_field(self):
        engine_screen = self.root.ids.main_screen.ids.enginescreen_1.ids.engine_vertical_box_layout
        try:
            if len(engine_screen.children) > 7:
                # Get the first child widget and set its size_hint_y to None
                first_child = engine_screen.children[0]
                first_child.size_hint_y = None

                # Remove the first child widget
                engine_screen.remove_widget(first_child)
                self.rpm_torque_rows -= 1
        except Exception as e:
            print(e)
            pass

    def add_gear_text_fields(self):
        parent_widget = self.root.ids.main_screen.ids.drivetrainscreen_1.ids.drivetrain_vertical_boxlayout
        for i in range(0, self.number_of_gears):
            self.box_layout = MDBoxLayout(orientation='horizontal',
                                          size_hint_x=.5,
                                          spacing=sp(20),
                                          id=f"gear_{i + 1}_boxlayout",
                                          adaptive_width=False,
                                          pos_hint={"center_x": .5, "center_y": 5})

            self.gear_textfield = MDTextField(hint_text=f"Gear {i + 1} Ratio",
                                              mode="fill",
                                              size_hint_x=None,
                                              on_text_validate=self.next_text_field,
                                              input_filter="float",
                                              width=sp(300))
            self.box_layout.add_widget(self.gear_textfield)
            parent_widget.add_widget(self.box_layout)

    def remove_gear_text_fields(self):
        parent_widget = self.root.ids.main_screen.ids.drivetrainscreen_1.ids.drivetrain_vertical_boxlayout
        try:
            if len(parent_widget.children) > 8:
                while len(parent_widget.children) != 8:
                    parent_widget.remove_widget(parent_widget.children[0])
        except Exception as e:
            print(e)
            pass

    def next_text_field(self, *args, same_box=False):
        current_text_field = args[0]
        boxlayout = current_text_field.parent
        vertical_boxlayout = boxlayout.parent
        current_id = vertical_boxlayout.children.index(boxlayout)
        current_id -= 1

        found_text_field = False
        while (current_id >= 0):
            if isinstance(vertical_boxlayout.children[current_id], MDBoxLayout):
                for i in reversed(vertical_boxlayout.children[current_id].children):
                    if isinstance(i, MDTextField):
                        found_text_field = True
                        i.focus = True
                        break
                if found_text_field: break

            current_id -= 1

    def get_tab_data(self):
        tab_data = {"car_info": {}, "engine_info": {}, "drivetrain_info": {}, "tire_info": {}, "aero_info": {}, "results_info": {}}

        # car info
        widget_parent = self.root.ids.main_screen.ids.carscreen_1.ids.carScreen_vertical_layout
        for i in widget_parent.children:
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j.text != "":
                        tab_data["car_info"][j._MDTextField__hint_text] = j.text
                    else:
                        tab_data["car_info"][j._MDTextField__hint_text] = None

        # engine info
        widget_parent = self.root.ids.main_screen.ids.enginescreen_1.ids.engine_vertical_box_layout
        rpm_torque_index = 0
        for i in reversed(widget_parent.children):
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j._MDTextField__hint_text == "RPM":
                        tab_data["engine_info"][f"RPM_{rpm_torque_index}"] = j.text
                    elif j._MDTextField__hint_text == "Torque":
                        tab_data["engine_info"][f"Torque_{rpm_torque_index}"] = j.text
                        rpm_torque_index += 1
                    else:
                        if j.text != "":
                            tab_data["engine_info"][j._MDTextField__hint_text] = j.text
                        else:
                            tab_data["engine_info"][j._MDTextField__hint_text] = None

        widget_parent = self.root.ids.main_screen.ids.drivetrainscreen_1.ids.drivetrain_vertical_boxlayout
        for i in widget_parent.children:
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j.text != "":
                        tab_data["drivetrain_info"][j._MDTextField__hint_text] = j.text
                    else:
                        tab_data["drivetrain_info"][j._MDTextField__hint_text] = None

        widget_parent = self.root.ids.main_screen.ids.tirescreen_1.ids.tire_vertical_boxlayout
        for i in widget_parent.children:
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j.text != "":
                        tab_data["tire_info"][j._MDTextField__hint_text] = j.text
                    else:
                        tab_data["tire_info"][j._MDTextField__hint_text] = None

        widget_parent = self.root.ids.main_screen.ids.aeroscreen_1.ids.aero_vertical_boxlayout
        for i in widget_parent.children:
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j.text != "":
                        tab_data["aero_info"][j._MDTextField__hint_text] = j.text
                    else:
                        tab_data["aero_info"][j._MDTextField__hint_text] = None

        widget_parent = self.root.ids.main_screen.ids.resultscreen_1.ids.resultsscreen_vertical_boxlayout
        for i in widget_parent.children:
            for j in i.children:
                if isinstance(j, MDTextField):
                    if j.text != "":
                        tab_data["results_info"][j._MDTextField__hint_text] = j.text
                    else:
                        tab_data["results_info"][j._MDTextField__hint_text] = None

        return tab_data

    def estimate_acceleration(self):

        # ui_data = self.get_tab_data()
        # print(ui_data)

        ui_data = {
            'car_info': {'Roll Stiffness': None, 'Roll Center Height': None, 'Track Width': None, 'Wheel Base': None, 'Car Mass Distribution': '50', 'Car Mass': '1035',
                         'Car Name': 'Mx5 nd 2015'},
            'engine_info': {'Idle RPM': '1000', 'Redline RPM': '7500', 'Torque_0': '150', 'RPM_1': '1000', 'Torque_1': '162', 'RPM_2': '2000', 'Torque_2': '170',
                            'RPM_3': '2500', 'Torque_3': '183', 'RPM_4': '3000', 'Torque_4': '191', 'RPM_5': '3500', 'Torque_5': '194', 'RPM_6': '4000',
                            'Torque_6': '189', 'RPM_7': '4500', 'Torque_7': '192', 'RPM_8': '5000', 'Torque_8': '185', 'RPM_9': '5500', 'Torque_9': '173',
                            'RPM_10': '6000', 'Torque_10': '165', 'RPM_11': '6500', 'Torque_11': '160', 'RPM_12': '7000', 'Torque_12': '152', 'RPM_13': '7500'},
            'drivetrain_info': {'Gear 6 Ratio': '0.58', 'Gear 5 Ratio': '0.71', 'Gear 4 Ratio': '1', 'Gear 3 Ratio': '1.4', 'Gear 2 Ratio': '2.06',
                                'Gear 1 Ratio': '3.54', 'Final Drive Ratio': '4.1', 'Gas Level': '0.3', 'Off Clutch RPM': '1400', 'Shifting Time (s)': '0.5',
                                'Drivetrain Loss': '12', 'Layout': 'rwd'},
            'tire_info': {'Rolling Resistance Coefficient (k)': '0.01', 'Tire Friction Coefficient (µ)': '0.92', 'Wheel Diameter': '16', 'Tire Aspect Ratio': '45',
                          'Tire Width': '195'},
            'aero_info': {'Downforce Distribution': '0', 'Downforce Total Area': '0', 'Negative Lift Coefficient': '0', 'Air Density': '1.225', 'Frontal Area': '1.82',
                          'Coefficient of Drag': '0.33'}, 'results_info': {'Final Speed': '100', 'Initial Speed': '0'}}

        def estimate_weight_shift(acceleration_value, wheelbase, track_width, roll_center_height, roll_stiffness):

            # Compute the roll angle caused by the weight shift
            roll_angle = acceleration_value * wheelbase / (2 * roll_stiffness)

            # Compute the weight shift as a fraction of the track width
            weight_shift = roll_angle * track_width / 2 * roll_center_height

            return weight_shift

        def find_accel_from_speed(speed, speed_values, accel_values):
            # acceleration is stored on an index based on the rpm, but because gears have different gear ratios
            # in each gear you will have different rpm at the same speed, this function, returns the acceleration value of the next gear
            # at the current speed
            rpm = np.searchsorted(speed_values, speed)
            return accel_values[rpm - 1]

        def find_optimum_upshift_point(gears_data):
            optimum_shift_points = []

            for i in range(len(gears_data) - 1):
                current_gear_acceleration = gears_data[i].accel

                next_gear_acceleration = []
                for j in range(len(current_gear_acceleration)):
                    if j >= len(gears_data[i + 1].accel):
                        break
                    next_gear_acceleration.append(find_accel_from_speed(gears_data[i].speed[j], gears_data[i + 1].speed, gears_data[i + 1].accel))
                next_gear_acceleration = np.array(next_gear_acceleration)

                for index, j in enumerate(range(min(len(current_gear_acceleration), len(next_gear_acceleration)))):
                    if current_gear_acceleration[j] < next_gear_acceleration[j]:
                        optimum_shift_points.append(index)
                else:
                    optimum_shift_points.append(len(current_gear_acceleration))

            return optimum_shift_points

        def find_starting_parameters(speed_value):
            for i in range(0, number_of_gears):
                idx = np.searchsorted(gears[i].speed, speed_value, side='right')
                if idx < len(gears[i].speed):
                    gear_value = i
                    rpm_value = idx
                    break
            return gear_value, rpm_value

        def upshift_lift_off(gear, index, initial_velocity, t):
            time_elapsed = 0
            count = 0
            while time_elapsed <= t:
                initial_velocity = gear.speed[index - 1]
                aux_velocity = initial_velocity - gear.speed[index]
                time_elapsed += abs(aux_velocity) / abs(
                    gear.accel[index - 1] - gear.torque_at_the_wheels[index - 1] / car_mass - gear.accel[index] - gear.torque_at_the_wheels[index] / car_mass)
                count += 1
                index -= 1
            return index, initial_velocity

        fig = make_subplots(rows=2, cols=3)

        # for weight shifting extra calculations
        car_extra_calculations = False
        car_wheelbase = None  # meters
        car_track_width = None  # meters
        car_roll_center_height = None  # meters
        car_roll_stiffness = None  # Nm/rad

        # target speeds
        initial_speed_kmh = int(ui_data["results_info"]["Initial Speed"])
        final_speed_kmh = int(ui_data["results_info"]["Final Speed"])

        # drivetrain info
        drivetrain_loss_percentage = float(ui_data["drivetrain_info"]["Drivetrain Loss"])
        layout = ui_data["drivetrain_info"]["Layout"]
        shift_time_s = float(ui_data["drivetrain_info"]["Shifting Time (s)"])
        disengagement_rpm = float(ui_data["drivetrain_info"]["Off Clutch RPM"])
        idle_rpm = int(ui_data["engine_info"]["Idle RPM"])
        redline_rpm = int(ui_data["engine_info"]["Redline RPM"])
        gas_level_data = float(ui_data["drivetrain_info"]["Gas Level"])

        # tire data
        tire_width = float(ui_data["tire_info"]["Tire Width"])
        tire_aspect = float(ui_data["tire_info"]["Tire Aspect Ratio"]) / 100
        tire_radial = float(ui_data["tire_info"]["Wheel Diameter"])
        tire_mu = float(ui_data["tire_info"]["Tire Friction Coefficient (µ)"])
        rolling_k = float(ui_data["tire_info"]["Rolling Resistance Coefficient (k)"])

        # general car data
        car_name = ui_data["car_info"]["Car Name"]
        car_mass = int(ui_data["car_info"]["Car Mass"])
        front_weight_distribution = int(ui_data["car_info"]["Car Mass Distribution"]) / 100
        cd_car = float(ui_data["aero_info"]["Coefficient of Drag"])
        frontal_area = float(ui_data["aero_info"]["Frontal Area"])
        air_density = float(ui_data["aero_info"]["Air Density"])
        lift_coefficient = float(ui_data["aero_info"]["Negative Lift Coefficient"])
        downforce_total_area = float(ui_data["aero_info"]["Downforce Total Area"])
        downforce_distribution = float(ui_data["aero_info"]["Downforce Distribution"])

        # gravitational acceleration m/s^2
        g = 9.81

        # transforming from km/h to m/s (SI units)
        initial_speed_ms = initial_speed_kmh / 3.6
        final_speed_ms = final_speed_kmh / 3.6

        # tire diameter in inch
        tire_diameter = (tire_width * tire_aspect * 2) / 25.4 + tire_radial

        # tire radius in meters (diameter in inch divided by 2 to get the radius)
        tire_radius = tire_diameter / 39.37 / 2

        # engine curves
        rpm_curve = np.array([])
        horsepower_curve = np.array([])
        torque_curve = np.array([])

        for key in ui_data["engine_info"].keys():
            # Check if key starts with "RPM_"
            if key.startswith("RPM_"):
                rpm_curve = np.append(rpm_curve, int(ui_data["engine_info"][key]))

        for key in ui_data["engine_info"].keys():
            # Check if key starts with "RPM_"
            if key.startswith("Torque_"):
                torque_curve = np.append(torque_curve, int(ui_data["engine_info"][key]))

        # data interpolation
        max_rpm = int(rpm_curve[len(rpm_curve) - 1])
        torque_curve = [x * (1 - drivetrain_loss_percentage / 100) for x in torque_curve]
        rpm_torque_interpolation = interp1d(rpm_curve, torque_curve, kind="cubic")
        rpm_curve = np.linspace(np.min(rpm_curve), np.max(rpm_curve), max_rpm - idle_rpm)
        torque_curve = rpm_torque_interpolation(rpm_curve)[:redline_rpm + 1]
        horsepower_curve = np.array([torque * rpm / 7127 for torque, rpm in zip(torque_curve, rpm_curve)])
        rpm_torque_interpolation = interp1d(rpm_curve, torque_curve, kind="cubic")
        torque_curve = rpm_torque_interpolation(rpm_curve)[:redline_rpm + 1]
        horsepower_interpolation = interp1d(rpm_curve, horsepower_curve, kind="cubic")
        horsepower_curve = horsepower_interpolation(rpm_curve)[:redline_rpm + 1]

        # gear ratios
        gear_ratios = []
        for key in reversed(ui_data["drivetrain_info"].keys()):
            if key.startswith("Gear "):
                gear_ratios.append(float(ui_data["drivetrain_info"][key]))
        gear_ratios.append(float(ui_data["drivetrain_info"]["Final Drive Ratio"]))
        number_of_gears = len(gear_ratios) - 1

        # limit of adhesion of tires in terms of max allowed force before entering dynamic friction
        if layout == "rwd":
            max_tractive_force = g * car_mass * (1 - front_weight_distribution) * tire_mu
        elif layout == "fwd":
            max_tractive_force = g * car_mass * front_weight_distribution * tire_mu

        class Gear:
            def __init__(self, ratio, accel, rpm, speed, torque_at_the_wheels, air_resistance_curve, downforce_curve):
                self.dropdown_rpm = None
                self.max_speed = None
                self.optimum_upshift = None
                self.ratio = ratio
                self.accel = accel
                self.rpm = rpm
                self.speed = speed
                self.torque_at_the_wheels = torque_at_the_wheels
                self.air_resistance = air_resistance_curve
                self.downforce_curve = downforce_curve

            def add_optimum_upshift(self, value):
                self.optimum_upshift = value
                self.max_speed = self.speed[min(value, len(self.accel) - 1)]

            def add_dropdown_rpm(self, value):
                self.dropdown_rpm = value

        # calculating relevant gear information
        gears = []
        for i in range(0, number_of_gears):

            # maximum speed at each rpm for specified gear, in m/s
            specific_speed = np.array([(x * tire_diameter) / (gear_ratios[i] * gear_ratios[len(gear_ratios) - 1] * 336) * 1.609 / 3.6 for x in rpm_curve])

            # air resistance in relation to speed, in Newtons
            air_resistance_curve = np.array([(cd_car * frontal_area * air_density * (x ** 2)) / 2 for x in specific_speed])

            # downforce in relation to speed, in Newtons
            downforce_curve = np.array([(lift_coefficient * downforce_total_area * air_density * (x ** 2)) / 2 for x in specific_speed])

            # torque at the wheels in Nm
            torque_at_the_wheels = np.array([x * gear_ratios[i] * gear_ratios[len(gear_ratios) - 1] for x in torque_curve])

            acceleration = np.array([])
            for index in range(0, len(torque_curve) - 1):
                downforce = downforce_curve[index] * (downforce_distribution if layout == 'fwd' else (1 - downforce_distribution))
                air_resistance = air_resistance_curve[index]
                rolling_resistance = rolling_k * g * car_mass

                aux_acceleration = (torque_at_the_wheels[index] / tire_radius - air_resistance - rolling_resistance) / car_mass
                if car_extra_calculations:
                    traction = min((max_tractive_force + downforce + estimate_weight_shift(aux_acceleration, car_wheelbase, car_track_width, car_roll_center_height,
                                                                                           car_roll_stiffness)) * tire_mu, aux_acceleration * car_mass)
                else:
                    traction = min((max_tractive_force + downforce) * tire_mu, aux_acceleration * car_mass)

                acceleration_at_specific_rpm = traction / car_mass
                if acceleration_at_specific_rpm > 0:
                    acceleration = np.append(acceleration, acceleration_at_specific_rpm)

            # putting together all the info
            gear_info = Gear(gear_ratios[i], acceleration, rpm_curve, specific_speed, torque_at_the_wheels, air_resistance_curve,
                             downforce_curve)
            gears.append(gear_info)

        # finding the optimum upshift shift points for each gear
        optimum_upshift = find_optimum_upshift_point(gears)
        for i in range(len(gears) - 1):
            gears[i].add_optimum_upshift(optimum_upshift[i])

        # calculating gear rpm dropdown when upshifting
        for i in range(len(gears) - 2):
            gears[i].add_dropdown_rpm(np.searchsorted(gears[i + 1].speed, gears[i].max_speed))

        # finding initial starting parameters
        current_speed_ms = initial_speed_ms
        current_gear, current_rpm = find_starting_parameters(current_speed_ms)
        total_time = 0
        standing_conditions = False

        while current_speed_ms <= final_speed_ms and current_rpm != -1 and current_gear != -1:

            # upshift
            if current_rpm == gears[current_gear].optimum_upshift:
                total_time += shift_time_s
                current_rpm = gears[current_gear].dropdown_rpm
                current_gear += 1

                idx, current_speed_ms = upshift_lift_off(gears[current_gear], current_rpm, current_speed_ms, shift_time_s)
                current_rpm = idx

            # standing start
            if current_gear == 0 and current_rpm <= disengagement_rpm - idle_rpm:

                # disengagement_rpm - idle_rpm because current_rpm is an index, and we store rpm values starting from idle_rpm, not 0
                while current_rpm <= disengagement_rpm - idle_rpm:
                    if not standing_conditions:
                        rolling_resistance = rolling_k * car_mass * g
                        rpm_delta = disengagement_rpm - idle_rpm

                        # uses the highest gas level either from the minimum necessary to start moving the car
                        # or the driver defined gas level, if higher
                        for i in range(len(gears[0].torque_at_the_wheels)):
                            if rolling_resistance < gears[0].torque_at_the_wheels[i] / tire_radius:
                                first_torque_entry = gears[0].torque_at_the_wheels[i] // tire_radius
                                current_rpm = i
                                break
                        gas_level = max(rolling_resistance / first_torque_entry, gas_level_data)
                        gas_level_step = (1 - gas_level) / rpm_delta
                        standing_conditions = True

                    current_rpm += 1
                    aux_time = (gears[current_gear].speed[current_rpm] - gears[current_gear].speed[current_rpm - 1]) / (
                            gears[current_gear].accel[current_rpm] * gas_level)
                    gas_level += gas_level_step
                    total_time += aux_time
                    current_speed_ms = gears[current_gear].speed[current_rpm]

            # accelerating
            if current_rpm != 0:  # 0 meaning idle_rpm
                total_time += ((gears[current_gear].speed[current_rpm] - gears[current_gear].speed[current_rpm - 1]) / gears[current_gear].accel[current_rpm])
            else:
                total_time += (gears[current_gear].speed[current_rpm] / gears[current_gear].accel[current_rpm])
            current_speed_ms = gears[current_gear].speed[current_rpm]
            current_rpm += 1

        for i in range(len(gears)):
            fig.add_trace(
                go.Scatter(x=gears[i].speed * 3.6, y=gears[i].torque_at_the_wheels,
                           name="Gear {}".format(i + 1)
                           ), row=2, col=2
            )
            # torque vs speed in each gear (max potential speed)

            fig.add_trace(
                go.Scatter(x=gears[i].speed * 3.6, y=gears[i].accel / g,
                           name="Gear {}".format(i + 1)
                           ), row=1, col=2
            )
            # acceleration vs speed graph

            # graphs
            # torque vs rpm graph
            fig = make_subplots(rows=2, cols=3)
            fig.add_trace(
                go.Scatter(x=rpm_curve, y=torque_curve,
                           name="Torque(Nm)"
                           ), row=1, col=1
            )

            # horsepower vs rpm graph
            fig.add_trace(
                go.Scatter(x=rpm_curve, y=horsepower_curve,
                           name='HP'
                           ), row=1, col=1
            )

        count2 = 1
        for i in gears:
            fig.add_trace(
                go.Scatter(x=i.speed * 3.6, y=i.torque_at_the_wheels,
                           name="Gear {}".format(count2)
                           ), row=2, col=2
            )
            # torque vs speed in each gear (max potential speed)

            fig.add_trace(
                go.Scatter(x=i.speed * 3.6, y=i.accel / g,
                           name="Gear {}".format(count2)
                           ), row=1, col=2
            )
            count2 += 1
            # acceleration vs speed graph

        for i in range(0, number_of_gears - 1):
            print(f"Gear {i + 1} Optimum Upshift - {gears[i].optimum_upshift + 1 + idle_rpm} RPM")
        print(f"{initial_speed_kmh} - {final_speed_kmh} km/h in {round(total_time, 3)} seconds")
        fig.update_layout(showlegend=False)
        fig.show()


AccelerationApproximator().run()
